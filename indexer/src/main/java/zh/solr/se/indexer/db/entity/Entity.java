package zh.solr.se.indexer.db.entity;


import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import zh.solr.se.indexer.util.StringUtil;

public abstract class Entity {
	private static final DateFormat INCOMING_DATE_FORMATTER = new SimpleDateFormat("yyyy-MM-dd", Locale.US);
	private static final DateFormat INCOMING_DATETIME_FORMATTER = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss", Locale.US);
	private static final DateFormat OUTGOING_DATE_FORMATTER = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss", Locale.US);

	public static final double UNKNOW_LAT_OR_LONG = 500.0;

	private Long pid;
	private String mapTaskId;

  @Override
  abstract public String toString();

  /**
   * Set the pid
   *
   * @param pid
   */
  public final void setPid(final Long pid) {
    this.pid = pid;
  }

  /**
   * Set the pid
   *
   * @param pid
   */
  public final void setPid(final String pid) {
    if((pid != null) && (pid.trim().length() > 0)) {
      try {
        setPid(Long.parseLong(pid));
      }
      catch(final NumberFormatException e) {
        // ignore
      }
    }
  }

  /**
   * Get the pid
   *
   * @return
   */
  public final Long getPid() {
    return pid;
  }

	/**
	 * Set the map task id generated by hadoop mapper
	 *
	 * @param mapTaskId
	 */
	public void setMapTaskId(final String mapTaskId) {
		if(mapTaskId != null) {
			this.mapTaskId = mapTaskId.trim();
		}
	}

  /**
	 * Get the map task id generated by hadoop mapper
	 *
	 * @return
	 */
	public String getMapTaskId() {
		return mapTaskId;
	}

  /**
   * The date coming in is expected to be in the format YYYY-MM-DD This method
   * parses that string and produces a Date object.
   *
   * @param date
   */
  protected Date parseIncomingDate(final String date) {
		return parseIncomingDate(date, INCOMING_DATE_FORMATTER);
	}

	/**
	 * The date coming in is expected to be in the format YYYY-MM-DD This method
	 * parses that string and produces a Date object.
	 *
	 * @param date to be parsed
	 * @param formatter formatter to use
	 */
	protected Date parseIncomingDate(final String date, final DateFormat formatter) {
    Date returnDate = null;
    // Assume date coming in is in format YYYY-MM-DD
    try {
      if(!StringUtil.isNullOrEmpty(date) && formatter != null) {
        returnDate = formatter.parse(date.trim());
      }
    }
    catch(final ParseException e) {
      // do nothing
    }
    return returnDate;
  }

	/**
	 * The datetime coming in is expected to be in the format YYYY-MM-DD hh:mm:ss
	 * This method parses that string and produces a Date object.
	 *
	 * @param datetime
	 */
	protected Date parseIncomingDatetime(final String datetime) {
		return parseIncomingDatetime(datetime, INCOMING_DATETIME_FORMATTER);
	}

	/**
	 * The datetime coming in is expected to be in the format YYYY-MM-DD hh:mm:ss
	 * This method parses that string and produces a Date object.
	 *
	 * @param datetime what to parse
	 * @param formatter formatter to use
	 */
	protected Date parseIncomingDatetime(final String datetime, final DateFormat formatter) {
		Date returnDatetime = null;
		// Assume date coming in is in format YYYY-MM-DD hh:mm:ss
		try {
			if(!StringUtil.isNullOrEmpty(datetime) && formatter != null) {
				returnDatetime = formatter.parse(datetime.trim());
			}
		}
		catch(final ParseException e) {
			// do nothing
		}
		return returnDatetime;
	}

	/**
	 * The date returned should be in the format YYYY-MM-DD hh:mm:ss
	 *
	 * @param date the date to be formatted
	 * @return
	 */
  protected String getOutingDate(final Date date) {
		return getOutingDate(date, OUTGOING_DATE_FORMATTER);
  }

	/**
	 * The date returned should be in the format YYYY-MM-DD hh:mm:ss
	 *
	 * @param date the date to be formatted
	 * @param formatter formatter to use
	 * @return
	 */
	protected String getOutingDate(final Date date, final DateFormat formatter) {
		String outgoingDate = null;
		if(date != null && formatter != null) {
			// Assume outgoing date in is in format YYYY-MM-DD hh:mm:ss
			outgoingDate = formatter.format(date);
		}
		return outgoingDate;
	}
}
